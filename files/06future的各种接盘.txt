promise模板使用*******************
用来保存或取出值。

#include <iostream>
#include<thread>
#include<future>
#include<vector>
#include<mutex>
using namespace std;

void myPrint(promise<int>& num,int i) {
		cout << "-----我的线程开始-----" << this_thread::get_id() << endl;
		cout << i << endl;
		this_thread::sleep_for(chrono::seconds(5));

		num.set_value(10000);
		cout << "-----我的线程结束-----" << this_thread::get_id() << endl;
		
}
void printProm (future<int> & result) {
	cout << "promise模板传参：" << result.get() << endl;
	return;
}


int main()
{
	cout << "主线程" << this_thread::get_id() << endl;

	promise<int> myprom;
	//先定义，并在适当的时候，可以在不同的线程中，把它取出来。

	thread thr(myPrint, ref(myprom),20); 
	//真正地传引用，加std::ref
	thr.join();

	future<int> temp = myprom.get_future();
	thread thr2(printProm,ref(temp));	
	thr2.join();

	cout<< "主线程结束" << this_thread::get_id() << endl;

	return 0;
}

输出窗口：*************************
主线程14348
-----我的线程开始-----1212
20
-----我的线程结束-----1212
promise模板传参：10000
主线程结束14348


练习package使用细节**************************

#include <iostream>
#include<thread>
#include<future>
#include<vector>
#include<mutex>
using namespace std;

int myPrint(int num) {
		cout << "-----我的线程开始-----" << this_thread::get_id() << endl;
		cout << num << endl;

		this_thread::sleep_for(chrono::seconds(5));

		cout << "-----我的线程结束-----" << this_thread::get_id() << endl;
		return 5;
}



int main()
{
	cout << "主线程" << this_thread::get_id() << endl;

	packaged_task<int(int)> mta(myPrint);
	
	vector<packaged_task<int(int)> >mytasks;

	mytasks.push_back(move(mta));
	//注意一对move语义
	auto iter = mytasks.begin();
	//注意auto指针

	packaged_task<int(int) > mta2 = move(*iter);

	mta2(400);	//像函数调用一样使用mta2,会卡5s

	future<int>result = mta2.get_future();

	cout << "（未创建线程，测试vector）函数返回：" << result.get() << endl;	
	//这里可以直接拿到结果,不卡

	cout<< "主线程结束" << this_thread::get_id() << endl;

	return 0;
}

输出窗口：*******************************

主线程3308
-----我的线程开始-----3308
400
-----我的线程结束-----3308
（未创建线程，测试vector）函数返回：5
主线程结束3308



获得future对象之二：package_task***********************
#include <iostream>
#include<thread>
#include<future>
#include<mutex>
using namespace std;

int myPrint(int num) {
		cout << "-----我的线程开始-----" << this_thread::get_id() << endl;
		cout << num << endl;

		this_thread::sleep_for(chrono::seconds(5));

		cout << "-----我的线程结束-----" << this_thread::get_id() << endl;
		return 5;
}



int main()
{
	cout << "主线程" << this_thread::get_id() << endl;

	packaged_task<int(int)> mta(myPrint);
	/*绑定:
	可调用程序(还可以是lambda表达式等)打包为packagetask，因为它含有future类对象。
	甚至mta可以像函数一样调用 mta(200),不过这不创建进程
	*/
	thread th(ref(mta), 200);//注意ref语义,相当于直接调用myPrint
	th.join();

	future<int>result = mta.get_future();
	cout << "我的线程返回：" << result.get() << endl;	
	//这里可以直接拿到结果,不卡


	cout<< "主线程结束" << this_thread::get_id() << endl;

	return 0;
}

输出结果：**********************************
主线程872
-----我的线程开始-----10868
200
-----我的线程结束-----10868
我的线程返回：5
主线程结束872





成员函数作为可调用对象；launch::deferred推迟且懒************

#include <iostream>
#include<thread>
#include<future>
#include<mutex>
using namespace std;

class A {
public:
	int myPrint(int num) {
		cout << num << endl;
		cout << "-----我的线程开始-----" << this_thread::get_id() << endl;
		this_thread::sleep_for(chrono::seconds(5));

		cout << "-----我的线程结束-----" << this_thread::get_id() << endl;
		return 5;
	}
};


int main()
{
	cout << "主线程" << this_thread::get_id() << endl;

	A a;

	/*
	①std::launch::deferred
		延迟到只有get或wait，才会执行√
		而且未创建新线程。
		*/
	future<int>rst = async(launch::deferred, &A::myPrint,	 &a,	 20);


	/*
	②成员函数作为可调用对象，传引用使得是对a本身操作。
	若无get等待，会执行完子线程才return。√
	why？
	*/
	future<int>result = async(&A::myPrint,	&a,	20);	
	cout << "②子线程返回数据:" << result.get() << endl;


	cout << "①子线程返回数据:" << rst.get() << endl;


	cout<< "主线程结束" << this_thread::get_id() << endl;

	return 0;
}

输出窗口**************
主线程14556
20
-----我的线程开始-----10940
-----我的线程结束-----10940
②子线程返回数据:5
20
-----我的线程开始-----14556
-----我的线程结束-----14556
①子线程返回数据:5
主线程结束14556





//第一个异步线程***************************
#include <iostream>
#include<thread>
#include<future>
#include<mutex>
using namespace std;


int myPrint() {
	cout << "-----我的线程开始-----" <<this_thread::get_id()<< endl;
	this_thread::sleep_for(chrono::seconds(5));

	cout << "-----我的线程结束-----" << endl;
	return 5;
}


int main()
{
	cout << "主线程" << this_thread::get_id() << endl;

	//异步线程拿到结果
	future<int>result = async(myPrint);

	//result.wait();
	cout << result.get() << endl;

	cout << "主程序完毕！！！";//最后执行这句
	return 0;
}
输出窗口***********
主线程7544
-----我的线程开始-----3692
-----我的线程结束-----
5
主程序完毕！！！