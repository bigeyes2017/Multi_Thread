
执行C++11锁和Windows临界区的切换********************************************************
通过注释#define _WINDOWSJQ_来切换。
//使用windows临界区，首先定义
//	#include <Windows.h>
//	#define _WINDOWSJQ_
//然后，创建变量：
//	CRITICAL_SECTION my_winsec;
//然后，使用之前初始化：（这里在构造sv时执行）
//	InitializeCriticalSection(&my_winsec);
//然后，使用临界变量
//		或者，可以创建智能锁wlock_guard

#include <iostream>
#include<thread>
#include<list>
#include<mutex>
#include <Windows.h>
#define _WINDOWSJQ_
using namespace std;

class wlock_guard {	//自定义一个像lock_guard的智能锁
public:
	wlock_guard(CRITICAL_SECTION* lock) {
		wiselock = lock;	//这里的lock已经初始化过了
		
		EnterCriticalSection(wiselock);
	}
	~wlock_guard() {
		LeaveCriticalSection(wiselock);
	}

private:
	CRITICAL_SECTION* wiselock;

};



class server {
public:

	server() {	//记得初始化

#ifdef _WINDOWSJQ_
		InitializeCriticalSection(&my_winsec);
#endif // _WINDOWSJQ_

	}
	void inlist() {
		for (int i = 0; i < 1000000; i++)
		{
			cout << "1添加一条请求到list：" << i << "线程id：" << this_thread::get_id() << endl;

			{
#ifdef _WINDOWSJQ_
				/*②此处使用RAII类建保姆式锁头，作用域内有效，一个顶两个*/
				wlock_guard uw(&my_winsec);
				lst.push_back(i);
#else
				/*②此处使用lock_guard类建保姆式锁头，作用域内有效，一个顶两个*/
				lock_guard<mutex> lg (mut);
				//lock_guard<mutex> lg2(mut);两次调用就错误了
				lst.push_back(i);
#endif // _WINDOWSJQ_

			}

		}
	};
	bool  dealout(int& command) {
#ifdef _WINDOWSJQ_	//①
			EnterCriticalSection(&my_winsec);
			if (!lst.empty()) {
				command = lst.front();
				lst.pop_front();

				LeaveCriticalSection(&my_winsec);

				return true;
			}
			LeaveCriticalSection(&my_winsec);

#else
		mut.lock();//锁1
		if (!lst.empty()) {
			command = lst.front();
			lst.pop_front();

			mut.unlock();

			return true;
		}
		mut.unlock();
	
#endif // _WINDOWSJQ_


		return false;
		

	}
	void outlist() {
		for (int i = 0; i < 1000000; i++)
		{
			int command = 0;
			bool flag = dealout(command);//此处传引用，command值被修改。

			if (flag) {
				cout << "取出并执行：" << command << "线程id：" << this_thread::get_id() << endl;
			}
			else {
				cout << "取出失败....线程id：" << this_thread::get_id() << endl;
			}
		}
	}
private:

	list<int>lst;
	mutex mut;
#ifdef _WINDOWSJQ_
	CRITICAL_SECTION my_winsec;
#endif // _WINDOWSJQ_


};


int main()
{
	cout << "主线程" << endl;

	server sv;
	thread inputthread(&server::inlist, &sv);	//此处传引用避免操作不到sv
	thread outputthread(&server::outlist, &sv);

	inputthread.join();
	outputthread.join();


	cout << "主程序完毕！！！";//最后执行这句
	return 0;
}
//输出窗口：*************************
正确