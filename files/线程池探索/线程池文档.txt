一、
client:
可以使用一个入口函数，多次创建线程的方法，来实现客户端的多线程。

server：
select管理线程分发。
1.accept。
创建一个线程函数：
{
accept函数。
互斥操作共享数据，fd_set。
}
如何通信？返回值。
{
fd_count = 返回值。
}
并等待若干秒。

共享数据：
如果读，则不锁。
写，才锁。

2.recv。

二、现有问题。
1.server存在多次创建。（两种方式：多次调用 Vs 多次创建。目前只会第er种）
解决，join
2.client创建2个，一个成功，一个失败。
观察，多线程是否开启。
3.server未发送消息。由于一直卡在dealRecvAccept处
所以主程序中的dealsend一直未执行。那边说到底还是顺序执行。这边也是。如果是创建线程的这种方式，想要不顺序执行还很难的。必须是，那边等着收，这边就不能不是一个发线程。那边等着发，这边也得是一个收线程。
4.必须以线程执行独立模块。
把创建线程与传可调用对象分开。
5.线程池：
线程创建。进入等待队列。
线程的等待队列。
线程出队，执行job。入运行队列。
线程执行完再次入执行队列。
6.观感：
0）这里其实是生产者、消费者进程。消费者之间互斥，生产者和消费者之间同步。
1）所谓进程同步，就是一个wait，一个signal。
2）wait？数据还没备齐的时候wait。
有job，没jobdata，可以有一个指向data的指针。
wait的进程有一个特点，就是数据为空。所以，只要数据为空，就可以把它放入等待队列中。反之，若数据不为空，就把它放在运行队列中。
3）放入数据后，signal醒一个进程，或一群进程。
争抢数据，但是要互斥访问。
操作流程（以类对象为可执行对象）：从读flag开始就互斥-》取公共数据-》放入自己的对象中-》设置flag，退出互斥。继续执行函数。

4）函数，还是可以在建立线程时传入，不过，没有数据就得wait。应有此意。

9）基本思路：
不会控制线程，但会控制线程的可执行对象。
这里有数据，有函数，选择类比较合适。
（c语言选择struct。）
模式：一个线程分发，多个线程执行。

10）执行流程：
多个线程。
线程执行workLine类，
类有：两个指针，分别指向函数，和参数。
应有：是否完成的isend标记，默认为false。
应有：condition_variable对象，
重载()函数,应等待唤醒，应执行函数和参数。//线程的执行类，流水线。	

一块数据。
执行线程，需要函数和数据。
可以定义一个JOB类，把二者都放里面。
函数如getData，insertData。
执行时，定义一个对象，以此调用函数，处理数据。
					//JOB类，工作台。


一个管理员。
创建workLine对象。使用new,以防整成局部变量。
将对象指针放进挂起列表中。
以workLine类为可执行对象,创建线程
放进线程数组中（释放时使用）
					//管理员创建线程.

创建一个JOB类对象。
目测有两种方法：一类内方法。二子类实现虚函数。
					//线程池启动


用户发来一个请求。
判断是否有效。				//管理员从挂起列表中取出一个对象指针。


取对象指针。				
从挂起列表的头部取一个JOB对象指针
如果没有，则在忙碌列表里，查找、移动isend为真的对象
					//取出没有工作的线程。
		

线程池判断请求类型。例如：插入数据	//设置对象的函数指针指向insertData函数，数组指针指向待插数据。



管理员将该对象的条件变量发出notify_all信号.//此处可知，线程wait处应有lambda表达式判断数据是否存在。

满足条件的进程执行，并放入忙碌队列。	//放入忙碌队列。
结束执行，对象内指针置NULL。		//迎接下一次工作

为了迎接下一次工作。
必须使得从重载函数()是循环。
为了能停止循环，
必须有继续|不继续的标记isGoNO;		//线程循环执行
					//放入等待队列。

终结？					//通过join方法可以实现。

互斥？	






教训：
记得，继承父类要加“：public 父类名”。否则显示父类不可更改。





















				







