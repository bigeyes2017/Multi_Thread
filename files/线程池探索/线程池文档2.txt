一、
client:
可以使用一个入口函数，多次创建线程的方法，来实现客户端的多线程。

server：
select管理线程分发。
1.accept。
创建一个线程函数：
{
accept函数。
互斥操作共享数据，fd_set。
}
如何通信？返回值。
{
fd_count = 返回值。
}
并等待若干秒。

共享数据：
如果读，则不锁。
写，才锁。

2.recv。

二、现有问题。
1.server存在多次创建。（两种方式：多次调用 Vs 多次创建。目前只会第er种）
解决，join
2.client创建2个，一个成功，一个失败。
观察，多线程是否开启。
3.server未发送消息。由于一直卡在dealRecvAccept处
所以主程序中的dealsend一直未执行。那边说到底还是顺序执行。这边也是。如果是创建线程的这种方式，想要不顺序执行还很难的。必须是，那边等着收，这边就不能不是一个发线程。那边等着发，这边也得是一个收线程。
4.必须以线程执行独立模块。
把创建线程与传可调用对象分开。
5.线程池：
线程创建。进入等待队列。
线程的等待队列。
线程出队，执行job。入运行队列。
线程执行完再次入执行队列。
6.观感：
0）这里其实是生产者、消费者进程。消费者之间互斥，生产者和消费者之间同步。
1）所谓进程同步，就是一个wait，一个signal。
2）wait？数据还没备齐的时候wait。
有job，没jobdata，可以有一个指向data的指针。
wait的进程有一个特点，就是数据为空。所以，只要数据为空，就可以把它放入等待队列中。反之，若数据不为空，就把它放在运行队列中。
3）放入数据后，signal醒一个进程，或一群进程。
争抢数据，但是要互斥访问。
操作流程（以类对象为可执行对象）：从读flag开始就互斥-》取公共数据-》放入自己的对象中-》设置flag，退出互斥。继续执行函数。

4）函数，还是可以在建立线程时传入，不过，没有数据就得wait。应有此意。

9）基本思路：
不会控制线程，但会控制线程的可执行对象。
这里有数据，有函数，选择类比较合适。
（c语言选择struct。）
模式：一个线程分发，多个线程执行。

10）执行流程：
多个线程。
线程执行workLine类，
类有：两个指针，分别指向函数，和参数。
应有：是否完成的isend标记，默认为false。
应有：condition_variable对象，
重载()函数,应等待唤醒，应执行函数和参数。//线程的执行类，流水线。	

一块数据。
执行线程，需要函数和数据。
可以定义一个JOB类，把二者都放里面。
函数如getData，insertData。
执行时，定义一个对象，以此调用函数，处理数据。
					//JOB类，工作台。


一个管理员。
创建workLine对象。使用new,以防整成局部变量。
将对象指针放进挂起列表中。
以workLine类为可执行对象,创建线程
放进线程数组中（释放时使用）
					//管理员创建线程.

创建一个JOB类对象。
目测有两种方法：一类内方法。二子类实现虚函数。
					//线程池启动


用户发来一个请求。
判断是否有效。				//管理员从挂起列表中取出一个对象指针。


取对象指针。				
从挂起列表的头部取一个JOB对象指针。
如果没有，则在忙碌列表里，查找、移动isend为真的对象
					//取出没有工作的线程。
		

线程池判断请求类型。例如：插入数据	//设置对象的函数指针指向insertData函数，数组指针指向待插数据。



管理员将该对象的条件变量发出notify_all信号.//此处可知，线程wait处应有lambda表达式判断数据是否存在。

满足条件的进程执行，并放入忙碌队列。	//放入忙碌队列。
结束执行，对象内指针置NULL。		//迎接下一次工作

为了迎接下一次工作。
必须使得从重载函数()是循环。
为了能停止循环，
必须有继续|不继续的标记isGoNO;		//线程循环执行
					//放入等待队列。

终结？					//通过join方法可以实现。

互斥？	

一、项目名称：
利用线程池，实现快速的增删改查。

二、基本思路：
1.通过线程的可执行对象，控制线程。

2.可执行对象为：类对象。

2.1类对象中有condition_variable变量，仅对该线程进行notify和wait。
2.2wait和notify的时机是，线程执行所需的函数、数据是否齐全。

3.函数指针，数据指针。其中函数指针可以用另一个Job类代替。

4如果被另一个Job类代替，则该Job应采取多态：
调用同一个函数，产生不同的行动。

5.如果是函数指针，应该在类外。


三、可改进部分：
1.如果线程互斥、同步更好实现，比如：
对不同数据的操作，
或者写入由主线程执行，子线程只读，
就能多条子线程并行。

2.多个分配任务的线程池管理员，也可以提高效率。

3.若是函数指针，应该不是在类里。

4.数据未设置成private。

四、经验：

0：通过Job的多态，实现同一函数的不同定义，与线程使用。

1.记得，继承父类要加“：public 父类名”。否则显示父类不可更改。

2.指针指向的，new的对象，如果要thread，要传ref（*pw）。
如果直接传（*pw），则会复制一次——如果有复制构造函数的话。

3.int *pi 定义了一个指针变量。其实还是个变量
变量类型：int*； 变量名：pi。所以会被自动释放。
如果它指向了一个new对象，则对象在堆区。
删除时，若delete pi，则删除的是new的对象
而不是pi；
pi还存在，如果后面还要使用，应该先置NULL：pi=NULL.























				







